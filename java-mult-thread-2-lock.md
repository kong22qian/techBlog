[TOC]

# Lock  system

##  锁区分

1. 线程是否要锁住同步资源： 锁住-悲观锁  不锁住-乐观锁<CAS 自选到一定条件成立在更改内存Value>  
2. 锁住同步资源失败，线程是否要阻塞： 阻塞   不阻塞-自旋锁&自适应自旋锁<jdk1.7自旋次数由jvm自适应>
3. 多个线程竞争同步资源细节：锁的膨胀升级-无锁、偏向锁、轻量级锁、重量级锁
4. 多个线程竞争同步资源是否需要排毒： 需要-公平锁  不需要-非公平锁
5. 一个线程的多个stage能否获取通一把锁： 能-可重入锁 不能-非可重入锁
6. 多个线程能不能共享一把锁： 能-共享锁   不能-排它锁
7. 锁的可控性： 隐式锁-JVM内置锁<synchronized>  显示锁-Lock实现<基于AQS，AbstractQueueSynchronized,
   源码可参考ReentrantLock，队列使用双向链表CLH，引出了公平和非公平锁>

## 悲观锁实例

```
凡是implement Lock interface || 使用sychronized，必然是悲观锁
```

## CPU上下文

> CPU-多核
> CPU划分出时间片，线程分别占用时间片
> 多线程之间的切换 - 即使时间片之间的切换  -> 线程上下文切换 <JVM从用户态空间，
> 请求内核态空间，向CPU发出切换指令，这个过程同样消耗CPU资源，所以最好无锁> 

## synchronized是JVM内置锁

> synchronized是JVM内置锁，通过内部对象Monitor同步，依赖底层硬件：
> synchronized: monitorenter -> logic code -> monitorexit

## 内存

> jvm内存主要区域：
> 堆内存 == 主内存
> 栈内存 == 线程私有 --> 数据存储在CPU寄存器
> 数据不同步或者不一致： 多个线程栈寄存器存储的变量value 与 内存之间的矛盾

## Object头部信息

JVM对象加锁原理
对象头：hash码、对象所属年度、对象锁、锁状态标志、线程ID...
对象实际数据:

对象的实例出在堆空间，对象的元数据存储在方法去（元数据区），对象象的引用存在栈空间

## 多线程实现的基础

硬件：
多核CPU 内存
保障了CAS、synchronized原子操作； 内存区域隔离

虚件：
JVM内存模型
划道

软件：
通过队列等逻辑，细化锁粒度的控制